#library "YYTMOD"
#include "zcommon.acs"
 
#define PLAYER_TID_START 1000
#define PLAYER_MAX 20
#define DISPLAYABLE_POWERUP_MAX 33
#define TEAR_STATS 7

int  SV_PLAYERS_NUMBERS_2_TIDS[PLAYER_MAX];
bool ENERGY_SHIELD_RELOAD = true;
int TEARS_STATS_BY_PLAYER[PLAYER_MAX][TEAR_STATS];

str  SV_DISPLAYABLE_POWERUPS[DISPLAYABLE_POWERUP_MAX] = {
    "CONTGiverP000A0", "GrowthHormonesGiverP001A0", "JesusJuiceGiverP002A0", "MomsHeelsGiverP003A0", "MomsLipstickGiverP004A0", 
    "MomsUnderwearGiverP005A0", "RoidRageGiverP006A0", "SafetyPinGiverP007A0", "SynthoilGiverP008A0", "SpeedBallGiverP009A0", 
    "Magic8BallGiverP010A0", "ScrewGiverP011A0", "ToothpicksGiverP012A0", "TornPhotoGiverP013A0", "AdrenalineGiverP014A0", 
    "TwentyTwentyGiverP015A0", "ALumpOfCoalGiverP016A0", "BloodOfTheMartyrGiverP017A0", "DarkMatterGiverP018A0", "Infestation2GiverP019A0",
    "LostContactGiverP020A0", "MomsContactsGiverP021A0", "MomsEyeGiverP022A0", "MutantSpiderGiverP023A0", "PiscesGiverP024A0",
    "RubberCementGiverP025A0", "SacredHeartGiverP026A0", "SpoonBenderGiverP027A0", "TheCommonColdGiverP028A0", "TheInnerEyeGiverP029A0",
    "TheParasiteGiverP030A0", "TheWizGiverP031A0", "BackstabberGiverP032A0"
};

str SV_DRAWABLE_CHARGE_BAR[40] = {
    "CHRBAR3", "CHRBAR4", "CHRBAR5", "CHRBAR6", "CHRBAR7", "CHRBAR8", "CHRBAR9", "CHRBAR10", "CHRBAR11", "CHRBAR12", "CHRBAR13", 
    "CHRBAR14", "CHRBAR15", "CHRBAR16", "CHRBAR17", "CHRBAR18", "CHRBAR19", "CHRBAR20", "CHRBAR21", "CHRBAR22", "CHRBAR23", "CHRBAR24", 
    "CHRBAR25", "CHRBAR26", "CHRBAR27", "CHRBAR28", "CHRBAR29", "CHRBAR30", "CHRBAR31", "CHRBAR32", "CHRBAR33", "CHRBAR34", "CHRBAR35", 
    "CHRBAR36", "CHRBAR37", "CHRBAR38", "CHRBAR39", "CHRBAR40", "CHRBAR41", "CHRBAR42"
};

script "yytmod_mensajesalida" DEATH
{
    int yyt_mensaje = random(1,3);
    switch(yyt_mensaje)
    {
        case 1:
        print(s:"No papu, asi no!");
        break;
 
        case 2:
        print(s:"Sos la cara de la verga.");
        break;
 
        case 3:
        print(s:"Ah listo...");
        break;
    }
}

script 2 (int value)
{
    SetActorProperty(0,APROP_Damage,value);
}

// Player Information Script
script 331 (void) NET CLIENTSIDE {
    Log(s:"Current player Number: ", i:PlayerNumber());
    Log(s:"Current player TID: ", i:ActivatorTID());
    Log(s:"Player list: ");

    for (int i=0; i<PLAYER_MAX; i++) {
        Log(s:"Player ", i:i, s:": TID -> ", i:SV_PLAYERS_NUMBERS_2_TIDS[i]);
    }
}

// Actor Information Script (solo para debugs)
script "printMyPointers" (void) {
    log(s:"MASTER: ", i:GetActorProperty(0, APROP_MasterTID));
    log(s:"TARGET: ", i:GetActorProperty(0, APROP_TargetTID));
    log(s:"TRACER: ", i:GetActorProperty(0, APROP_TracerTID));
    log(s:"X: ", f:GetActorX(0));
    log(s:"Y: ", f:GetActorY(0));
    log(s:"Z: ", f:GetActorZ(0));
}

script 332 OPEN {
    //Translations
    CreateTranslation (2, 128:225=[0,0,0]:[24,13,2]); // A Lump of Coal
    CreateTranslation (3, 192:193=[0,0,0]:[238,25,34], 194:197=[0,0,0]:[158,6,12]); // Blood of the Martyr
    CreateTranslation (4, 192:193=[0,0,0]:[42,42,42], 194:224=[0,0,0]:[23,23,23]); // Dark Matter
    CreateTranslation (6, 128:225=[0,0,0]:[179,26,60]); // Moms Contact
    CreateTranslation (8, 192:193=[0,0,0]:[214,215,223], 194:197=[0,0,0]:[199,225,230]); // Sacred Heart
    CreateTranslation (9, 192:193=[0,0,0]:[122,38,158], 194:197=[0,0,0]:[111,32,155], 198:224=[0,0,0]:[97,19,146]); // Spoon Bender
    CreateTranslation (10, 192:193=[0,0,0]:[83,115,168], 194:197=[0,0,0]:[81,116,174], 198:224=[0,0,0]:[76,115,178]); // Lost Contact
    CreateTranslation (11, 128:225=[0,0,0]:[85,154,117]); // The Common Cold
    CreateTranslation (13, 192:193=[0,0,0]:[187,98,69], 194:197=[0,0,0]:[154,78,40], 198:224=[0,0,0]:[128,71,43]); // The Parasite
}

Script 333 (void) NET {
    GiveInventory("DetonateWaskaAction", 1);
}
 
script "setEnergyShieldReload" (int flag) {
    ENERGY_SHIELD_RELOAD = flag;
}
 
script 335 ENTER {
    ACS_ExecuteAlways(338, 0);

    int pnum = PlayerNumber();
    int classNum = PlayerClass(pnum);
    if (classNum == 0) {
        ACS_NamedExecuteAlways("loadTearStatsData", 0, pnum);
                
        while (true) {
            if (ENERGY_SHIELD_RELOAD) {
                GiveInventory("EnergyShieldAmmo",1);
                Delay(1);
            }
            Delay(1);
        }
    }
}
 
script 336 DEATH {
    int classNum = PlayerClass(PlayerNumber());
    if (classNum == 0) {
        ACS_NamedExecuteAlways("resetTearStats", 0);

        if (!ACS_NamedExecuteWithResult("checkForNoGiverInInventory", 18)) {
            TakeInventory("BlackIsaacHands", 1);
            GiveInventory("IsaacHands", 1);
        }

        for (int i=0; i<DISPLAYABLE_POWERUP_MAX; i++) {
            TakeInventory(StrLeft(SV_DISPLAYABLE_POWERUPS[i], StrLen(SV_DISPLAYABLE_POWERUPS[i])-6), 1);
        }
    }

    SV_PLAYERS_NUMBERS_2_TIDS[PlayerNumber()] = 0;
    Thing_ChangeTID(PLAYER_TID_START+PlayerNumber(), 0);
}
 
script 337 RESPAWN {
    ACS_ExecuteAlways(338, 0);
}
 
script 338 (void) {
    int playerNum = PlayerNumber();
    int newTID = playerNum + PLAYER_TID_START;
    SV_PLAYERS_NUMBERS_2_TIDS[playerNum] = newTID;
    Thing_ChangeTID(0, newTID);
}
 
script "isMasterPressingAltFire" (void) {
    int playerTID = GetActorProperty(0, APROP_MasterTID);
    int playerNum = ACS_NamedExecuteWithResult("getPlayerNumberFromTID", playerTID); 
    int buttons = GetPlayerInput(playerNum, INPUT_BUTTONS);
 
    SetResultValue(buttons & BT_ALTATTACK);
}

script "getPlayerNumberFromTID" (int ptid) {
    for (int i=0; i<PLAYER_MAX; i++) {
 
        if (SV_PLAYERS_NUMBERS_2_TIDS[i] == ptid) {
            SetResultValue(i);
            break;
        }
    }
}

//Hago estas dos funciones porque los jumps de decorate son una cagada
script "checkForNoAmmoInInventory" (int choice) {
    switch(choice) {
        case 1: {
            SetResultValue(CheckInventory("EnergyShieldAmmo") == 0);
        }; break;
    }
}

script "checkForNoAmmoInPointerInventory" (int choice) {
    switch(choice) {
        case 1: {
            int ptid = GetActorProperty(0, APROP_MasterTID);
            SetResultValue(CheckActorInventory(ptid, "EnergyShieldAmmo") == 0);
        }; break;
    }
}

script "loadChargedAttack" (int fullyCharged) {
    SetUserVariable(0, "user_charge_state", 0);
    int progressFactor = 40.0 / fullyCharged;
    int playFeedbackSound = 1;
    int chargedTime, progressC;
    ACS_NamedExecuteWithResult("displayChargeBar", 1);

    while (ACS_NamedExecuteWithResult("isPressingFire")) {
        progressC = (progressFactor * chargedTime) >> 16;
        ACS_NamedExecuteWithResult("showProgressChargeBar", progressC);

        if (chargedTime < fullyCharged) { chargedTime++; }
        else {
            if (playFeedbackSound) {
                PlaySound(0, "agge/charged", CHAN_AUTO);
                playFeedbackSound = 0;
            }
        }
        Delay(1);
    }

    ACS_NamedExecuteWithResult("displayChargeBar", 0);
    if (chargedTime == fullyCharged) {
        ACS_NamedExecuteWithResult("pausePlayer", 1);
        SetActorPitch(0, 0.1);
        SetUserVariable(0, "user_charge_state", 1);
    }
    else {
        SetUserVariable(0, "user_charge_state", 2);
    }
}

script "displayChargeBar" (int isOn) CLIENTSIDE {
    if (isOn) {
        SetFont("CHRBAR1");
        HudMessage(s:"A"; HUDMSG_PLAIN, 2, 0, 0.01, 0.01, 0);
    }
    else {
        HudMessage(s:""; HUDMSG_PLAIN, 2, 0, 0, 0, 1);
        HudMessage(s:""; HUDMSG_PLAIN, 1, 0, 0, 0, 1);
    }
}

script "showProgressChargeBar" (int entry) CLIENTSIDE {
    SetFont(SV_DRAWABLE_CHARGE_BAR[entry]);
    HudMessage(s:"A"; HUDMSG_PLAIN, 1, 0, 0.013, 0.013, 0);
}

script "pausePlayer" (int activeFlag) {
    if (activeFlag) {
        Thing_Stop(0);
        SetPlayerProperty(0, activeFlag, PROP_TOTALLYFROZEN);
    }
    else {
        SetPlayerProperty(0, activeFlag, PROP_TOTALLYFROZEN);
    }
}

script "getChargeState" (void) {
    int chargeState = GetUserVariable(0, "user_charge_state");
    SetResultValue(chargeState);
}

script "isPressingFire" (void) {
    int buttons = GetPlayerInput(PlayerNumber(), INPUT_BUTTONS);
    SetResultValue(buttons & BT_ATTACK);
}

// codigo escopeta terro
// COMIENZO
script 891 (void)
{
    while(checkinventory("SynthFireActive")>0)
    {       
        if(getplayerinput(PlayerNumber(), INPUT_BUTTONS) & BT_ATTACK)
        {
            giveinventory("SynthFireLeft",1);
            while(checkinventory("SynthFireLeft">0) || getplayerinput(PlayerNumber(), INPUT_BUTTONS) & BT_ATTACK) { delay(1); }
            takeinventory("SynthFireLeft",1);
        }
        delay(1);
    }
}

// Right (secondary) weapon.
script 892 (void)
{
    while(CheckInventory("SynthFireActive")>0)
    {
        if(GetPlayerInput(PlayerNumber(), INPUT_BUTTONS) & BT_ALTATTACK)
        {
            GiveInventory("SynthFireRight",1);
            while(GetPlayerInput(PlayerNumber(), INPUT_BUTTONS) & BT_ALTATTACK) { delay(1); }
            TakeInventory("SynthFireRight",1);
        }
        delay(1);
    }
}
// FIN

script "setDamageBoostPerTime" (int boost, int tics, int maxi) {
    // Prerequisito: El actor que llama al script tiene que tener user_deadflag.
    for (int i=0; i<maxi; i++) {
        Delay(tics);
        if (GetUserVariable(0, "user_deadflag")) { terminate; }
        int newDmg = GetActorProperty(0, APROP_Damage) + boost;
        SetActorProperty(0, APROP_Damage, newDmg);
    }
}

script "isEffectChanceSuccessful" (int chance) {
    int res = Random(1, 100);
    SetResultValue(res <= chance);
}

// Obligado a usar switch a causa de que ACS no se banca otras variables que
// no sean int como parametros y que admite una cantidad limitada de ellos
script "applyEffect" (int option, int dur) {
    int mtid, ptid;
    switch(option) {
        case 1: {
            mtid = UniqueTID();
            int ftid = UniqueTID();

            Thing_ChangeTID(0, mtid);
            Spawn("FearEffect", GetActorX(0), GetActorY(0), GetActorZ(0), ftid);
            SetActivator(ftid);
            SetPointer(AAPTR_TRACER, mtid);
            SetActorProperty(mtid, APROP_Frightened, 1);
            Delay(dur);
            SetActorProperty(mtid, APROP_Frightened, 0);
            TakeActorInventory(mtid, "FearDebuffGiver", 1);
            SetActorState(0, "Death");
            Thing_ChangeTID(mtid, 0);
            Thing_ChangeTID(ftid, 0);
        }; break;
        case 2: {
            while(GetActorProperty(0, APROP_Health) > 0.0) { Delay(1); }
            Spawn("FriendlyMiniArachnotron", GetActorX(0), GetActorY(0), GetActorZ(0));
        }; break;
        case 3: {
            //No puede atacar ni moverse pero tampoco se le puede hacer daño
            mtid = UniqueTID();
            ptid = UniqueTID();

            Thing_ChangeTID(0, mtid);
            Spawn("PetrifyingEffect", GetActorX(0), GetActorY(0), GetActorZ(0), ptid);
            SetActivator(ptid);
            SetPointer(AAPTR_TRACER, mtid);
            Thing_Deactivate(mtid);
            Delay(dur);
            Thing_Activate(mtid);
            TakeActorInventory(mtid, "PetrifyingDebuffGiver", 1);
            SetActorState(0, "Death");
            Thing_ChangeTID(mtid, 0);
            Thing_ChangeTID(ptid, 0);
        }; break;
        case 4: {
            int angle = GetActorAngle(0) >> 8;
            if (angle < 128) { angle = angle + 128; } else { angle = angle - 128; }
            // IMPORTANTE: Si es piercing tear tiene que knockbackear menos
            ThrustThing(angle, 7, 0, 0);
        }; break;
        case 5: {
            // Poison hace el daño de la lágrima al monstruo cada 2 segundos una X cantidad de veces
            int times = dur / 35;
            int poisonDmg = GetActorProperty(0, APROP_Damage);
            SetActivator(0, AAPTR_TRACER);
            mtid = UniqueTID();
            ptid = UniqueTID();

            Thing_ChangeTID(0, mtid);
            Spawn("PoisonEffect", GetActorX(0), GetActorY(0), GetActorZ(0), ptid);
            SetActivator(ptid);
            SetPointer(AAPTR_TRACER, mtid);
            for (int i=0; i<times; i++) {
                Thing_Damage2(mtid, poisonDmg, "Poison");
                Delay(70);
            }

            SetActorState(0, "Death");
            Thing_ChangeTID(mtid, 0);
            Thing_ChangeTID(ptid, 0);
        }; break;
        case 6: {
            // Bleeding hace 10% de su salud maxima de daño al monstruo cada 5 segundos y no tiene limite de tiempo.
            // Importante: No debe afectar a monstruos tipo BOSSES.
            mtid = UniqueTID();
            int btid = UniqueTID();

            Thing_ChangeTID(0, mtid);
            Spawn("BleedingEffect", GetActorX(0), GetActorY(0), GetActorZ(0), btid);
            SetActivator(btid);
            SetPointer(AAPTR_TRACER, mtid);

            //LA SUPERCLASE DEL MONSTER TIENE QUE TENER user_max_health SETEADO
            while (GetActorProperty(mtid, APROP_Health) > 0.0) {
                Thing_Damage2(mtid, multiplyValue(GetUserVariable(mtid, "user_max_healh"), 0.1), "Bleeding");
                Delay(175);
            }

            SetActorState(0, "Death");
            Thing_ChangeTID(mtid, 0);
            Thing_ChangeTID(btid, 0);
        }; break;
    }
}

script "showTranslation" (int option) CLIENTSIDE {
    Thing_SetTranslation(0, option);
}

script "deathTimer" (int tics) {
    Delay(tics);
    SetActorState(0, "Death");
}

script "getUniqueTID" (void) {
    SetResultValue(UniqueTID());
}

script "getTracerHeight" (void) {
    int ttid = GetActorProperty(0, APROP_TracerTID);
    SetResultValue(GetActorProperty(ttid, APROP_Height) >> 16);
}

script "shellsLeft" (void) {
    SetResultValue(CheckInventory("ShellsLeft"));
}

script "shells" (void) {
    SetResultValue(CheckInventory("Shell"));
}







/************************
*   ARMA 4 CLASE AGGE   
************************/

/*
** FUNCIONES DE BASE DE DATOS
*/

// La intención es usar la DB para mantener el progreso de los stats IN-GAME. Por ahora, no
// hay planes de dejar persistida la data una vez se cierra el server.
str TEARS_STATS_TABLE[TEAR_STATS] = {
    "0Radius", "1Height", "2Damage", "3Range", "4Speed Boost", "5Scale", "6Fire Rate Boost"
};

script "saveTearStatsData" (void) {
    int i, j;
    str pName;
    BeginDBTransaction();
    for (i=0; i<PLAYER_MAX; i++) {
        if (TEARS_STATS_BY_PLAYER[i][0] == 0) { continue; }
        pName = StrParam(s:"Player", d:i);
        for (j=0; j<TEAR_STATS; j++) {
            SetDBEntry(pName, TEARS_STATS_TABLE[j], TEARS_STATS_BY_PLAYER[i][j]);
        }
    }
    EndDBTransaction();
}

script "loadTearStatsData" (int pnum) {
    int i;

    str pName = StrParam(s:"Player", d:pnum);
    int tearStats = GetDBEntries(pName);

    if (CountDBResults(tearStats) == 0) {
        ACS_NamedExecuteAlways("resetTearStats", 0);
        FreeDBResults(tearStats);
        terminate;
    }

    for (i=0; i<TEAR_STATS; i++) {
        TEARS_STATS_BY_PLAYER[pnum][i] = GetDBResultValue(tearStats, i);
        if (IsNetworkGame()) {
            ACS_NamedExecuteAlways("sendToClient", 0, pnum, i, TEARS_STATS_BY_PLAYER[pnum][i]);
        }
    }

    FreeDBResults(tearStats);
}







/*
** COMPORTAMIENTO Y STATS DEL ARMA
*/

// Tear Stats Information Script
script 334 (void) NET CLIENTSIDE {
    int pnum = PlayerNumber();
    Log(s:"Radius: ", i:TEARS_STATS_BY_PLAYER[pnum][0]);
    Log(s:"Height: ", i:TEARS_STATS_BY_PLAYER[pnum][1]);
    Log(s:"Damage: ", i:TEARS_STATS_BY_PLAYER[pnum][2]);
    Log(s:"Range: ", i:TEARS_STATS_BY_PLAYER[pnum][3]);
    Log(s:"Speed Boost: ", i:TEARS_STATS_BY_PLAYER[pnum][4]);
    Log(s:"Scale: ", i:TEARS_STATS_BY_PLAYER[pnum][5]);
    Log(s:"Fire Rate Boost: ", i:TEARS_STATS_BY_PLAYER[pnum][6]);
}

script 330 UNLOADING {
    ACS_NamedExecuteAlways("saveTearStatsData", 0);
}

// Para persistir datos a través de los juegos se necesita una primary key más poderosa
/*script 329 (int pnum) DISCONNECT {
    int classNum = PlayerClass(pnum);
    if (classNum == 0) {
        TEARS_STATS_BY_PLAYER[pnum][0] = 2;
        TEARS_STATS_BY_PLAYER[pnum][1] = 3;
        TEARS_STATS_BY_PLAYER[pnum][2] = 2;
        TEARS_STATS_BY_PLAYER[pnum][3] = 35;
        TEARS_STATS_BY_PLAYER[pnum][4] = 0;
        TEARS_STATS_BY_PLAYER[pnum][5] = 1;
        TEARS_STATS_BY_PLAYER[pnum][6] = 1;
        ACS_NamedExecuteAlways("saveTearStatsData", 0);
    }
}*/

script "resetTearStats" (void) {
    int pnum = PlayerNumber();

    // Radius y height no se pueden cambiar en zandro 3.0
    TEARS_STATS_BY_PLAYER[pnum][0] = 2;  //Radius
    TEARS_STATS_BY_PLAYER[pnum][1] = 3;  //Height
    TEARS_STATS_BY_PLAYER[pnum][2] = 2;  //Damage
    TEARS_STATS_BY_PLAYER[pnum][3] = 35; //Range (en tics)
    TEARS_STATS_BY_PLAYER[pnum][4] = 0;  //Speed Boost
    TEARS_STATS_BY_PLAYER[pnum][5] = 1;  //Scale
    TEARS_STATS_BY_PLAYER[pnum][6] = 1;  //Fire Rate Boost

    if (IsNetworkGame()) {
        for (int i=0; i<TEAR_STATS; i++) {
            ACS_NamedExecuteAlways("sendToClient", 0, pnum, i, TEARS_STATS_BY_PLAYER[pnum][i]);
        }
    }
}

script "sendToClient" (int pnumber, int entry, int val) CLIENTSIDE {
    TEARS_STATS_BY_PLAYER[pnumber][entry] = val;
}

script "addTearBoost" (int boostType, int bonus) {
    int pnum = PlayerNumber();
    TEARS_STATS_BY_PLAYER[pnum][boostType] = TEARS_STATS_BY_PLAYER[pnum][boostType] + bonus;
    if (boostType == 6 && TEARS_STATS_BY_PLAYER[pnum][boostType] < 1) { TEARS_STATS_BY_PLAYER[pnum][boostType] = 1; }
    if (IsNetworkGame()) {
        ACS_NamedExecuteAlways("sendToClient", 0, pnum, boostType, TEARS_STATS_BY_PLAYER[pnum][boostType]);
    }
}

script "setTearStats" (void) {
    int ptid = GetActorProperty(0, APROP_TargetTID);
    int pnum = ACS_NamedExecuteWithResult("getPlayerNumberFromTID", ptid); 
    ACS_NamedExecuteAlways("setRadius", 0, TEARS_STATS_BY_PLAYER[pnum][0]);
    ACS_NamedExecuteAlways("setHeight", 0, TEARS_STATS_BY_PLAYER[pnum][1]);
    ACS_NamedExecuteAlways("setDamage", 0, TEARS_STATS_BY_PLAYER[pnum][2], ptid);
    ACS_NamedExecuteAlways("setRange", 0, TEARS_STATS_BY_PLAYER[pnum][3]);
    ACS_NamedExecuteAlways("setSpeed", 0, TEARS_STATS_BY_PLAYER[pnum][4]);
    ACS_NamedExecuteAlways("setScale", 0, TEARS_STATS_BY_PLAYER[pnum][5]);

    if (CheckActorInventory(ptid, "ALumpOfCoalGiver") == 1) {
        Thing_SetTranslation(0, 2);
        ACS_NamedExecuteAlways("setDamageBoostPerTime", 0, 1, 35, 10);
    }

    if (CheckActorInventory(ptid, "BloodOfTheMartyrGiver") == 1) {
        Thing_SetTranslation(0, 3);
    }

    if (CheckActorInventory(ptid, "LostContactGiver") == 1) {
        Thing_SetTranslation(0, 10);
    }

    if (CheckActorInventory(ptid, "SacredHeartGiver") == 1) {
        Thing_SetTranslation(0, 8);
    }

    if (CheckActorInventory(ptid, "SpoonBenderGiver") == 1) {
        Thing_SetTranslation(0, 9);
    }

    if (CheckActorInventory(ptid, "TheParasiteGiver") == 1) {
        Thing_SetTranslation(0, 13);
    }
}

script "setRadius" (int radius) {
    SetActorProperty(0, APROP_Radius, radius << 16);
}

script "setHeight" (int hgt) {
    SetActorProperty(0, APROP_Height, hgt << 16);
}

script "setDamage" (int damage, int ptid) {
    damage = applyGiversToDamage(damage, ptid);
    SetActorProperty(0, APROP_Damage, damage);
}

function int applyGiversToDamage(int damage, int ptid) {
    if (CheckActorInventory(ptid, "SacredHeartGiver") == 1) {
        damage = multiplyValue(damage, 2.3);
    }

    if (CheckActorInventory(ptid, "AdrenalineGiver") == 1 && GetActorProperty(ptid, APROP_Health) <= 100) {
        damage = damage + (2 * ((GetActorProperty(ptid, APROP_Health) - 100) / -10)); // +2 damage cada -10 de HP, máximo +18 con menos de 10 HP
    }

    if (CheckActorInventory(ptid, "TwentyTwentyGiver") == 1) {
        damage = multiplyValue(damage, 0.75);
    }

    return damage;
}

function int multiplyValue(int value, int multiplier) {
    // Multiplica (o divide) a value.
    // value es un integer y multiplier es un fixed number.
    // Se randomiza el redondeo de float->integer en base a la parte decimal del float.
    // Ej: 0.5 tiene 50% chance de redondear a 1 y 50% chance de redondear a 0.
    int dmgCutDec = (value * multiplier) & 0x0000FFFF;
    int rand = Random(0x00000000, 0x0000FFFF);
    if (dmgCutDec <= rand) {
        value = ((value * multiplier) >> 16);
    }
    else {
        value = ((value * multiplier) >> 16) + 1;
    }

    return value;
}

script "setRange" (int range) {
    while (range > 0) {
        if (GetUserVariable(0, "user_deadflag")) {
            SetUserVariable(0, "user_deadflag", range);
            terminate;
        }

        range--;
        Delay(1);
    }

    ThrustThingZ(0, 15, 1, 0);
    SetUserVariable(0, "user_deadflag", 1);
    SetActorState(0, "DeathEnd");
}

script "setSpeed" (int boost) {
    if (boost != 0) {
        int newVelX = ((GetActorVelX(0) * boost) / 100) + GetActorVelX(0);
        int newVelY = ((GetActorVelY(0) * boost) / 100) + GetActorVelY(0);
        int newVelZ = ((GetActorVelZ(0) * boost) / 100) + GetActorVelZ(0);
        SetActorVelocity(0, newVelX, newVelY, newVelZ, false, false);
    }
}

// Al ser algo puramente visual queda del lado del cliente
script "setScale" (int scale) CLIENTSIDE {
    switch(scale) {
        case 1: {
            SetActorProperty(0, APROP_ScaleX, 0.125);
            SetActorProperty(0, APROP_ScaleY, 0.125);
        }; break;
        case 2: {
            SetActorProperty(0, APROP_ScaleX, 0.25);
            SetActorProperty(0, APROP_ScaleY, 0.25);
        }; break;
        case 3: {
            SetActorProperty(0, APROP_ScaleX, 0.375);
            SetActorProperty(0, APROP_ScaleY, 0.375);
        }; break;
        case 4: {
            SetActorProperty(0, APROP_ScaleX, 0.5);
            SetActorProperty(0, APROP_ScaleY, 0.5);
        }; break;
        case 5: {
            SetActorProperty(0, APROP_ScaleX, 0.625);
            SetActorProperty(0, APROP_ScaleY, 0.625);
        }; break;
        case 6: {
            SetActorProperty(0, APROP_ScaleX, 0.75);
            SetActorProperty(0, APROP_ScaleY, 0.75);
        }; break;
        case 7: {
            SetActorProperty(0, APROP_ScaleX, 0.875);
            SetActorProperty(0, APROP_ScaleY, 0.875);
        }; break;
        case 8: {
            SetActorProperty(0, APROP_ScaleX, 1.0);
            SetActorProperty(0, APROP_ScaleY, 1.0);
        }; break;
    }
}

script "getFireRateBoost" (void) {
    SetResultValue(TEARS_STATS_BY_PLAYER[PlayerNumber()][6]);
}

script "showPowerups" (int displayFlag) CLIENTSIDE {
    for (int i=1; i<=DISPLAYABLE_POWERUP_MAX; i++) {
        if (displayFlag) {
            SetFont(StrRight(SV_DISPLAYABLE_POWERUPS[i-1], 6));
            if (CheckInventory(StrLeft(SV_DISPLAYABLE_POWERUPS[i-1], StrLen(SV_DISPLAYABLE_POWERUPS[i-1])-6)) == 1) {
                HudMessage(s:"A"; HUDMSG_PLAIN, i, 0, FixedDiv(i << 16, 65.0), 0.05, 0);
            }
            else {
                HudMessage(s:"A"; HUDMSG_PLAIN|HUDMSG_ALPHA, i, 0, FixedDiv(i << 16, 65.0), 0.05, 0, 0.25);
            }
        }
        else {
            HudMessage(s:""; HUDMSG_PLAIN, i, 0, 0, 0, 1);
        }
    }
}

script "checkForNoGiverInInventory" (int option) {
    SetResultValue(CheckInventory(StrLeft(SV_DISPLAYABLE_POWERUPS[option], StrLen(SV_DISPLAYABLE_POWERUPS[option])-6)) == 0);
}

script "checkForNoGiverInTargetInventory" (int option) {
    int ptid = GetActorProperty(0, APROP_TargetTID);
    SetResultValue(CheckActorInventory(ptid, StrLeft(SV_DISPLAYABLE_POWERUPS[option], StrLen(SV_DISPLAYABLE_POWERUPS[option])-6)) == 0);
}

// Por defecto duran 2:30 minutos, se puede agregar un parametro más adelante para duraciones especificas
script "activateTemporalPowerup" (int option) {
    str powerup = StrLeft(SV_DISPLAYABLE_POWERUPS[option], StrLen(SV_DISPLAYABLE_POWERUPS[option])-6);
    GiveInventory(powerup, 1);

    switch(option) {
        case 26: {
            ACS_NamedExecuteAlways("addTearBoost", 0, 2, 1);
            ACS_NamedExecuteAlways("addTearBoost", 0, 6, -2);
            ACS_NamedExecuteAlways("addTearBoost", 0, 4, -75);
            //ACS_NamedExecuteAlways("addTearBoost", 0, 1, 2); //Más height (para cuando zandro lo soporte)
        }
    }

    Delay(5250);

    switch(option) {
        case 26: {
            ACS_NamedExecuteAlways("addTearBoost", 0, 2, -1);
            ACS_NamedExecuteAlways("addTearBoost", 0, 6, 2);
            ACS_NamedExecuteAlways("addTearBoost", 0, 4, 75);
            //ACS_NamedExecuteAlways("addTearBoost", 0, 1, -2); //Más height (para cuando zandro lo soporte)
        }
    }

    TakeInventory(powerup, 1);
}

script "setParasiteChildrenStats" (int ctid) {
    int masterDmg = GetActorProperty(0, APROP_Damage);
    int masterScaleX = GetActorProperty(0, APROP_ScaleX);
    int masterScaleY = GetActorProperty(0, APROP_ScaleY);

    SetActivator(ctid);

    SetActorProperty(0, APROP_Damage, masterDmg / 2);

    //Lo mismo sería para height y radius
    SetActorProperty(0, APROP_ScaleX, masterScaleX / 2);
    SetActorProperty(0, APROP_ScaleY, masterScaleY / 2);

    int range = GetUserVariable(0, "user_deadflag");
    if (range < 5) { range = 5; }
    ACS_NamedExecuteAlways("setRange", 0, range);
    Thing_ChangeTID(ctid, 0);
}

script "isDamageTooLow" (int threshold) {
    SetResultValue(GetActorProperty(0, APROP_Damage) < threshold);
}

script "checkForBackstabDebuff" (void) {
    int projectileAngle = GetActorAngle(0) >> 8;
    int projectileDamage = GetActorProperty(0, APROP_Damage);

    SetActivator(0, AAPTR_TRACER);

    int monsterAngle = GetActorAngle(0) >> 8;
    int minThreshold, maxThreshold;

    if (monsterAngle >= 32 && monsterAngle < 224) {
        minThreshold = monsterAngle - 32;
        maxThreshold = monsterAngle + 32;
        if (projectileAngle >= minThreshold && projectileAngle <= maxThreshold) {
            ACS_NamedExecuteAlways("dealBackstabDamage", 0, projectileDamage);
        }
    }
    else {
        if (monsterAngle < 32) {
            minThreshold = monsterAngle + 224;
            maxThreshold = monsterAngle + 32;
            if (projectileAngle >= minThreshold || projectileAngle <= maxThreshold) {
                ACS_NamedExecuteAlways("dealBackstabDamage", 0, projectileDamage);
            }
        }
        else {
            minThreshold = monsterAngle - 224;
            maxThreshold = monsterAngle - 32;
            if (projectileAngle <= minThreshold || projectileAngle >= maxThreshold) {
                ACS_NamedExecuteAlways("dealBackstabDamage", 0, projectileDamage);
            }
        }
    }
}

script "dealBackstabDamage" (int damage) {
    // Segundo golpe y efecto bleeding
    Thing_Damage2(0, damage, "None");
    ACS_NamedExecuteAlways("applyEffect", 0, 6);
}