#library "YYTMOD"
#include "zcommon.acs"
 
#define PLAYER_TID_START 1000
#define PLAYER_MAX 20
#define DISPLAYABLE_POWERUP_MAX 33

/* Al no poder usar array de 2 dimensiones en variables globales, no se puede persistir los tear stats por jugador.
** ----------------
** POSIBLE SOLUCIÓN
**
** Hacer un array que sea variable de mapa donde:
**  clave -> player number de clase Agge
**  valor -> array global que guarde sus stats
**
** PRECONDICIÓN:
**  + Player number se mantiene IGUAL.
**  + Script "getPlayerNumberFromTID" tiene que ser 100% confiable para casos donde el activador NO SEA el player.
** -----------------
** OTRA SOLUCIÓN
** 
** Hacer X globales para X cantidad de jugadores con la clase.
** Se guarda el player number en el primer elemento y a la hora de actualizar se compara contra ese elemento.
** Mismas precondiciones que el caso anterior.
*/
global int 1:INITIALIZE_FLAG;

int  SV_PLAYERS_NUMBERS_2_TIDS[PLAYER_MAX];
bool ENERGY_SHIELD_RELOAD = true;

str  SV_DISPLAYABLE_POWERUPS[DISPLAYABLE_POWERUP_MAX] = {
    "CONTGiverP000A0", "GrowthHormonesGiverP001A0", "JesusJuiceGiverP002A0", "MomsHeelsGiverP003A0", "MomsLipstickGiverP004A0", 
    "MomsUnderwearGiverP005A0", "RoidRageGiverP006A0", "SafetyPinGiverP007A0", "SynthoilGiverP008A0", "SpeedBallGiverP009A0", 
    "Magic8BallGiverP010A0", "ScrewGiverP011A0", "ToothpicksGiverP012A0", "TornPhotoGiverP013A0", "AdrenalineGiverP014A0", 
    "TwentyTwentyGiverP015A0", "ALumpOfCoalGiverP016A0", "BloodOfTheMartyrGiverP017A0", "DarkMatterGiverP018A0", "Infestation2GiverP019A0",
    "LostContactGiverP020A0", "MomsContactsGiverP021A0", "MomsEyeGiverP022A0", "MutantSpiderGiverP023A0", "PiscesGiverP024A0",
    "RubberCementGiverP025A0", "SacredHeartGiverP026A0", "SpoonBenderGiverP027A0", "TheCommonColdGiverP028A0", "TheInnerEyeGiverP029A0",
    "TheParasiteGiverP030A0", "TheWizGiverP031A0", "BackstabberGiverP032A0"
};

str SV_DRAWABLE_CHARGE_BAR[40] = {
    "CHRBAR3", "CHRBAR4", "CHRBAR5", "CHRBAR6", "CHRBAR7", "CHRBAR8", "CHRBAR9", "CHRBAR10", "CHRBAR11", "CHRBAR12", "CHRBAR13", 
    "CHRBAR14", "CHRBAR15", "CHRBAR16", "CHRBAR17", "CHRBAR18", "CHRBAR19", "CHRBAR20", "CHRBAR21", "CHRBAR22", "CHRBAR23", "CHRBAR24", 
    "CHRBAR25", "CHRBAR26", "CHRBAR27", "CHRBAR28", "CHRBAR29", "CHRBAR30", "CHRBAR31", "CHRBAR32", "CHRBAR33", "CHRBAR34", "CHRBAR35", 
    "CHRBAR36", "CHRBAR37", "CHRBAR38", "CHRBAR39", "CHRBAR40", "CHRBAR41", "CHRBAR42"
};

script "yytmod_mensajesalida" DEATH
{
    int yyt_mensaje = random(1,3);
    switch(yyt_mensaje)
    {
        case 1:
        print(s:"No papu, asi no!");
        break;
 
        case 2:
        print(s:"Sos la cara de la verga.");
        break;
 
        case 3:
        print(s:"Ah listo...");
        break;
    }
}

script 2 (int value)
{
    SetActorProperty(0,APROP_Damage,value);
}

// Player Information Script
script 331 (void) NET CLIENTSIDE {
    Log(s:"Current player Number: ", i:PlayerNumber());
    Log(s:"Current player TID: ", i:ActivatorTID());
    Log(s:"Player list: ");

    for (int i=0; i<PLAYER_MAX; i++) {
        Log(s:"Player ", i:i, s:": TID -> ", i:SV_PLAYERS_NUMBERS_2_TIDS[i]);
    }
}

// Actor Information Script (solo para debugs)
script "printMyPointers" (void) {
    log(s:"MASTER: ", i:GetActorProperty(0, APROP_MasterTID));
    log(s:"TARGET: ", i:GetActorProperty(0, APROP_TargetTID));
    log(s:"TRACER: ", i:GetActorProperty(0, APROP_TracerTID));
    log(s:"X: ", f:GetActorX(0));
    log(s:"Y: ", f:GetActorY(0));
    log(s:"Z: ", f:GetActorZ(0));
}

script 332 OPEN {
    //Translations
    CreateTranslation (2, 128:225=[0,0,0]:[24,13,2]); // A Lump of Coal
    CreateTranslation (3, 192:193=[0,0,0]:[238,25,34], 194:197=[0,0,0]:[158,6,12]); // Blood of the Martyr
    CreateTranslation (4, 192:193=[0,0,0]:[42,42,42], 194:224=[0,0,0]:[23,23,23]); // Dark Matter
    CreateTranslation (6, 128:225=[0,0,0]:[179,26,60]); // Moms Contact
    CreateTranslation (8, 192:193=[0,0,0]:[214,215,223], 194:197=[0,0,0]:[199,225,230]); // Sacred Heart
    CreateTranslation (9, 192:193=[0,0,0]:[122,38,158], 194:197=[0,0,0]:[111,32,155], 198:224=[0,0,0]:[97,19,146]); // Spoon Bender
    CreateTranslation (10, 192:193=[0,0,0]:[83,115,168], 194:197=[0,0,0]:[81,116,174], 198:224=[0,0,0]:[76,115,178]); // Lost Contact
    CreateTranslation (11, 128:225=[0,0,0]:[85,154,117]); // The Common Cold
    CreateTranslation (13, 192:193=[0,0,0]:[187,98,69], 194:197=[0,0,0]:[154,78,40], 198:224=[0,0,0]:[128,71,43]); // The Parasite
}

Script 333 (void) NET {
    GiveInventory("DetonateWaskaAction", 1);
}
 
script "setEnergyShieldReload" (int flag) {
    ENERGY_SHIELD_RELOAD = flag;
}
 
script 335 ENTER {
    ACS_ExecuteAlways(338, 0);

    int classNum = PlayerClass(PlayerNumber());
    if (classNum == 0) {
        if (!INITIALIZE_FLAG) {
            ACS_NamedExecuteAlways("resetTearStats", 0);
            INITIALIZE_FLAG = 1;
        }
                
        while (true) {
            if (ENERGY_SHIELD_RELOAD) {
                GiveInventory("EnergyShieldAmmo",1);
                Delay(1);
            }
            Delay(1);
        }
    }
}
 
script 336 DEATH {
    int classNum = PlayerClass(PlayerNumber());
    if (classNum == 0) {
        ACS_NamedExecuteAlways("resetTearStats", 0);

        if (!ACS_NamedExecuteWithResult("checkForNoGiverInInventory", 18)) {
            TakeInventory("BlackIsaacHands", 1);
            GiveInventory("IsaacHands", 1);
        }

        for (int i=0; i<DISPLAYABLE_POWERUP_MAX; i++) {
            TakeInventory(StrLeft(SV_DISPLAYABLE_POWERUPS[i], StrLen(SV_DISPLAYABLE_POWERUPS[i])-6), 1);
        }
    }

    SV_PLAYERS_NUMBERS_2_TIDS[PlayerNumber()] = 0;
    Thing_ChangeTID(PLAYER_TID_START+PlayerNumber(), 0);
}
 
script 337 RESPAWN {
    ACS_ExecuteAlways(338, 0);
}
 
script 338 (void) {
    int playerNum = PlayerNumber();
    int newTID = playerNum + PLAYER_TID_START;
    SV_PLAYERS_NUMBERS_2_TIDS[playerNum] = newTID;
    Thing_ChangeTID(0, newTID);
}
 
script "isMasterPressingAltFire" (void) {
    int playerTID = GetActorProperty(0, APROP_MasterTID);
    int playerNum = ACS_NamedExecuteWithResult("getPlayerNumberFromTID", playerTID); 
    int buttons = GetPlayerInput(playerNum, INPUT_BUTTONS);
 
    SetResultValue(buttons & BT_ALTATTACK);
}

script "getPlayerNumberFromTID" (int ptid) {
    for (int i=0; i<PLAYER_MAX; i++) {
 
        if (SV_PLAYERS_NUMBERS_2_TIDS[i] == ptid) {
            SetResultValue(i);
            break;
        }
    }
}

//Hago estas dos funciones porque los jumps de decorate son una cagada
script "checkForNoAmmoInInventory" (int choice) {
    switch(choice) {
        case 1: {
            SetResultValue(CheckInventory("EnergyShieldAmmo") == 0);
        }; break;
    }
}

script "checkForNoAmmoInPointerInventory" (int choice) {
    switch(choice) {
        case 1: {
            int ptid = GetActorProperty(0, APROP_MasterTID);
            SetResultValue(CheckActorInventory(ptid, "EnergyShieldAmmo") == 0);
        }; break;
    }
}

script "loadChargedAttack" (int fullyCharged) {
    SetUserVariable(0, "user_charge_state", 0);
    int progressFactor = 40.0 / fullyCharged;
    int playFeedbackSound = 1;
    int chargedTime, progressC;
    ACS_NamedExecuteWithResult("displayChargeBar", 1);

    while (ACS_NamedExecuteWithResult("isPressingFire")) {
        progressC = (progressFactor * chargedTime) >> 16;
        ACS_NamedExecuteWithResult("showProgressChargeBar", progressC);

        if (chargedTime < fullyCharged) { chargedTime++; }
        else {
            if (playFeedbackSound) {
                PlaySound(0, "agge/charged", CHAN_AUTO);
                playFeedbackSound = 0;
            }
        }
        Delay(1);
    }

    ACS_NamedExecuteWithResult("displayChargeBar", 0);
    if (chargedTime == fullyCharged) {
        ACS_NamedExecuteWithResult("pausePlayer", 1);
        SetActorPitch(0, 0.1);
        SetUserVariable(0, "user_charge_state", 1);
    }
    else {
        SetUserVariable(0, "user_charge_state", 2);
    }
}

script "displayChargeBar" (int isOn) CLIENTSIDE {
    if (isOn) {
        SetFont("CHRBAR1");
        HudMessage(s:"A"; HUDMSG_PLAIN, 2, 0, 0.01, 0.01, 0);
    }
    else {
        HudMessage(s:""; HUDMSG_PLAIN, 2, 0, 0, 0, 1);
        HudMessage(s:""; HUDMSG_PLAIN, 1, 0, 0, 0, 1);
    }
}

script "showProgressChargeBar" (int entry) CLIENTSIDE {
    SetFont(SV_DRAWABLE_CHARGE_BAR[entry]);
    HudMessage(s:"A"; HUDMSG_PLAIN, 1, 0, 0.013, 0.013, 0);
}

script "pausePlayer" (int activeFlag) {
    if (activeFlag) {
        Thing_Stop(0);
        SetPlayerProperty(0, activeFlag, PROP_TOTALLYFROZEN);
    }
    else {
        SetPlayerProperty(0, activeFlag, PROP_TOTALLYFROZEN);
    }
}

script "getChargeState" (void) {
    int chargeState = GetUserVariable(0, "user_charge_state");
    SetResultValue(chargeState);
}

script "isPressingFire" (void) {
    int buttons = GetPlayerInput(PlayerNumber(), INPUT_BUTTONS);
    SetResultValue(buttons & BT_ATTACK);
}

// codigo escopeta terro
// COMIENZO
script 891 (void)
{
    while(checkinventory("SynthFireActive")>0)
    {       
        if(getplayerinput(PlayerNumber(), INPUT_BUTTONS) & BT_ATTACK)
        {
            giveinventory("SynthFireLeft",1);
            while(checkinventory("SynthFireLeft">0) || getplayerinput(PlayerNumber(), INPUT_BUTTONS) & BT_ATTACK) { delay(1); }
            takeinventory("SynthFireLeft",1);
        }
        delay(1);
    }
}

// Right (secondary) weapon.
script 892 (void)
{
    while(CheckInventory("SynthFireActive")>0)
    {
        if(GetPlayerInput(PlayerNumber(), INPUT_BUTTONS) & BT_ALTATTACK)
        {
            GiveInventory("SynthFireRight",1);
            while(GetPlayerInput(PlayerNumber(), INPUT_BUTTONS) & BT_ALTATTACK) { delay(1); }
            TakeInventory("SynthFireRight",1);
        }
        delay(1);
    }
}
// FIN

script "setDamageBoostPerTime" (int boost, int tics, int maxi) {
    // Prerequisito: El actor que llama al script tiene que tener user_deadflag.
    for (int i=0; i<maxi; i++) {
        Delay(tics);
        if (GetUserVariable(0, "user_deadflag")) { terminate; }
        int newDmg = GetActorProperty(0, APROP_Damage) + boost;
        SetActorProperty(0, APROP_Damage, newDmg);
    }
}

script "isEffectChanceSuccessful" (int chance) {
    int res = Random(1, 100);
    SetResultValue(res <= chance);
}

// Obligado a usar switch a causa de que ACS no se banca otras variables que
// no sean int como parametros y que admite una cantidad limitada de ellos
script "applyEffect" (int option, int dur) {
    int mtid, ptid;
    switch(option) {
        case 1: {
            mtid = UniqueTID();
            int ftid = UniqueTID();

            Thing_ChangeTID(0, mtid);
            Spawn("FearEffect", GetActorX(0), GetActorY(0), GetActorZ(0), ftid);
            SetActivator(ftid);
            SetPointer(AAPTR_TRACER, mtid);
            SetActorProperty(mtid, APROP_Frightened, 1);
            Delay(dur);
            SetActorProperty(mtid, APROP_Frightened, 0);
            TakeActorInventory(mtid, "FearDebuffGiver", 1);
            SetActorState(0, "Death");
            Thing_ChangeTID(mtid, 0);
            Thing_ChangeTID(ftid, 0);
        }; break;
        case 2: {
            while(GetActorProperty(0, APROP_Health) > 0.0) { Delay(1); }
            Spawn("FriendlyMiniArachnotron", GetActorX(0), GetActorY(0), GetActorZ(0));
        }; break;
        case 3: {
            //No puede atacar ni moverse pero tampoco se le puede hacer daño
            mtid = UniqueTID();
            ptid = UniqueTID();

            Thing_ChangeTID(0, mtid);
            Spawn("PetrifyingEffect", GetActorX(0), GetActorY(0), GetActorZ(0), ptid);
            SetActivator(ptid);
            SetPointer(AAPTR_TRACER, mtid);
            Thing_Deactivate(mtid);
            Delay(dur);
            Thing_Activate(mtid);
            TakeActorInventory(mtid, "PetrifyingDebuffGiver", 1);
            SetActorState(0, "Death");
            Thing_ChangeTID(mtid, 0);
            Thing_ChangeTID(ptid, 0);
        }; break;
        case 4: {
            int angle = GetActorAngle(0) >> 8;
            if (angle < 128) { angle = angle + 128; } else { angle = angle - 128; }
            // IMPORTANTE: Si es piercing tear tiene que knockbackear menos
            ThrustThing(angle, 7, 0, 0);
        }; break;
        case 5: {
            // Poison hace el daño de la lágrima al monstruo cada 2 segundos una X cantidad de veces
            int times = dur / 35;
            int playerTID = GetActorProperty(0, APROP_TargetTID);
            SetActivator(0, AAPTR_TRACER);
            mtid = UniqueTID();
            ptid = UniqueTID();

            Thing_ChangeTID(0, mtid);
            Spawn("PoisonEffect", GetActorX(0), GetActorY(0), GetActorZ(0), ptid);
            SetActivator(ptid);
            SetPointer(AAPTR_TRACER, mtid);
            for (int i=0; i<times; i++) {
                Thing_Damage2(mtid, GetUserVariable(playerTID, "user_tear_damage"), "Poison");
                Delay(70);
            }

            SetActorState(0, "Death");
            Thing_ChangeTID(mtid, 0);
            Thing_ChangeTID(ptid, 0);
        }; break;
        case 6: {
            //Bleeding hace 10% de su salud maxima de daño al monstruo cada 5 segundos y no tiene limite de tiempo.
            mtid = UniqueTID();
            int btid = UniqueTID();

            Thing_ChangeTID(0, mtid);
            Spawn("BleedingEffect", GetActorX(0), GetActorY(0), GetActorZ(0), btid);
            SetActivator(btid);
            SetPointer(AAPTR_TRACER, mtid);

            //LA SUPERCLASE DEL MONSTER TIENE QUE TENER user_max_health SETEADO
            while (GetActorProperty(mtid, APROP_Health) > 0.0) {
                Thing_Damage2(mtid, multiplyValue(GetUserVariable(0, "user_max_healh"), 0.1), "Bleeding");
                Delay(175);
            }

            SetActorState(0, "Death");
            Thing_ChangeTID(mtid, 0);
            Thing_ChangeTID(btid, 0);
        }; break;
    }
}

script "showTranslation" (int option) CLIENTSIDE {
    Thing_SetTranslation(0, option);
}

script "deathTimer" (int tics) {
    Delay(tics);
    SetActorState(0, "Death");
}

script "getUniqueTID" (void) {
    SetResultValue(UniqueTID());
}

script "getTracerHeight" (void) {
    int ttid = GetActorProperty(0, APROP_TracerTID);
    SetResultValue(GetActorProperty(ttid, APROP_Height) >> 16);
}





/************************
*   ARMA 4 CLASE AGGE   
************************/

// Tear Stats Information Script
script 334 (void) NET CLIENTSIDE {
    Log(s:"Radius: ", i:GetUserVariable(0, "user_tear_radius"));
    Log(s:"Height: ", i:GetUserVariable(0, "user_tear_height"));
    Log(s:"Damage: ", i:GetUserVariable(0, "user_tear_damage"));
    Log(s:"Range: ", i:GetUserVariable(0, "user_tear_range"));
    Log(s:"Speed Boost: ", i:GetUserVariable(0, "user_tear_speed_boost"));
    Log(s:"Scale: ", i:GetUserVariable(0, "user_tear_scale"));
    Log(s:"Fire Rate Boost: ", i:GetUserVariable(0, "user_tear_fire_rate_boost"));
}

script "resetTearStats" (void) {
    // Radius y height no se pueden cambiar en zandro 3.0
    SetUserVariable(0, "user_tear_radius", 2); //Radius
    SetUserVariable(0, "user_tear_height", 3); //Height
    SetUserVariable(0, "user_tear_damage", 2); //Damage
    SetUserVariable(0, "user_tear_range", 35); //Range (en tics)
    SetUserVariable(0, "user_tear_speed_boost", 0); //Speed Boost
    SetUserVariable(0, "user_tear_scale", 1); //Scale
    SetUserVariable(0, "user_tear_fire_rate_boost", 1);  //Fire Rate Boost
}

script "addTearBoost" (int boostType, int bonus) {
    switch(boostType) {
        case 0: {
            SetUserVariable(0, "user_tear_radius", GetUserVariable(0, "user_tear_radius") + bonus);
        }; break;
        case 1: {
            SetUserVariable(0, "user_tear_height", GetUserVariable(0, "user_tear_height") + bonus);
        }; break;
        case 2: {
            SetUserVariable(0, "user_tear_damage", GetUserVariable(0, "user_tear_damage") + bonus);
        }; break;
        case 3: {
            SetUserVariable(0, "user_tear_range", GetUserVariable(0, "user_tear_range") + bonus);
        }; break;
        case 4: {
            SetUserVariable(0, "user_tear_speed_boost", GetUserVariable(0, "user_tear_speed_boost") + bonus);
        }; break;
        case 5: {
            SetUserVariable(0, "user_tear_scale", GetUserVariable(0, "user_tear_scale") + bonus);
        }; break;
        case 6: {
            SetUserVariable(0, "user_tear_fire_rate_boost", GetUserVariable(0, "user_tear_fire_rate_boost") + bonus);
        }; break;
    }
    if (boostType == 6 && GetUserVariable(0, "user_tear_fire_rate_boost") < 1) { SetUserVariable(0, "user_tear_fire_rate_boost", 1); }
}

script "setTearStats" (void) {
    int ptid = GetActorProperty(0, APROP_TargetTID);
    ACS_NamedExecuteAlways("setRadius", 0, GetUserVariable(ptid, "user_tear_radius"));
    ACS_NamedExecuteAlways("setHeight", 0, GetUserVariable(ptid, "user_tear_height"));
    ACS_NamedExecuteAlways("setDamage", 0, GetUserVariable(ptid, "user_tear_damage"), ptid);
    ACS_NamedExecuteAlways("setRange", 0, GetUserVariable(ptid, "user_tear_range"));
    ACS_NamedExecuteAlways("setSpeed", 0, GetUserVariable(ptid, "user_tear_speed_boost"));
    ACS_NamedExecuteAlways("setScale", 0, GetUserVariable(ptid, "user_tear_scale"));

    if (CheckActorInventory(ptid, "ALumpOfCoalGiver") == 1) {
        Thing_SetTranslation(0, 2);
        ACS_NamedExecuteAlways("setDamageBoostPerTime", 0, 1, 35, 10);
    }

    if (CheckActorInventory(ptid, "BloodOfTheMartyrGiver") == 1) {
        Thing_SetTranslation(0, 3);
    }

    if (CheckActorInventory(ptid, "LostContactGiver") == 1) {
        Thing_SetTranslation(0, 10);
    }

    if (CheckActorInventory(ptid, "SacredHeartGiver") == 1) {
        Thing_SetTranslation(0, 8);
    }

    if (CheckActorInventory(ptid, "SpoonBenderGiver") == 1) {
        Thing_SetTranslation(0, 9);
    }

    if (CheckActorInventory(ptid, "TheParasiteGiver") == 1) {
        Thing_SetTranslation(0, 13);
    }
}

script "setRadius" (int radius) {
    SetActorProperty(0, APROP_Radius, radius << 16);
}

script "setHeight" (int hgt) {
    SetActorProperty(0, APROP_Height, hgt << 16);
}

script "setDamage" (int damage, int ptid) {
    damage = applyGiversToDamage(damage, ptid);
    SetActorProperty(0, APROP_Damage, damage);
}

function int applyGiversToDamage(int damage, int ptid) {
    if (CheckActorInventory(ptid, "SacredHeartGiver") == 1) {
        damage = multiplyValue(damage, 2.3);
    }

    if (CheckActorInventory(ptid, "AdrenalineGiver") == 1 && GetActorProperty(ptid, APROP_Health) <= 100) {
        damage = damage + (2 * ((GetActorProperty(ptid, APROP_Health) - 100) / -10)); // +2 damage cada -10 de HP, máximo +18 con menos de 10 HP
    }

    if (CheckActorInventory(ptid, "TwentyTwentyGiver") == 1) {
        damage = multiplyValue(damage, 0.75);
    }

    return damage;
}

function int multiplyValue(int value, int multiplier) {
    // Multiplica (o divide) a value.
    // value es un integer y multiplier es un fixed number.
    // Se randomiza el redondeo de float->integer en base a la parte decimal del float.
    // Ej: 0.5 tiene 50% chance de redondear a 1 y 50% chance de redondear a 0.
    int dmgCutDec = (value * multiplier) & 0x0000FFFF;
    int rand = Random(0x00000000, 0x0000FFFF);
    if (dmgCutDec <= rand) {
        value = ((value * multiplier) >> 16);
    }
    else {
        value = ((value * multiplier) >> 16) + 1;
    }

    return value;
}

script "setRange" (int range) {
    while (range > 0) {
        if (GetUserVariable(0, "user_deadflag")) {
            SetUserVariable(0, "user_deadflag", range);
            terminate;
        }

        range--;
        Delay(1);
    }

    ThrustThingZ(0, 15, 1, 0);
    SetUserVariable(0, "user_deadflag", 1);
    SetActorState(0, "DeathEnd");
}

script "setSpeed" (int boost) {
    if (boost != 0) {
        int newVelX = ((GetActorVelX(0) * boost) / 100) + GetActorVelX(0);
        int newVelY = ((GetActorVelY(0) * boost) / 100) + GetActorVelY(0);
        int newVelZ = ((GetActorVelZ(0) * boost) / 100) + GetActorVelZ(0);
        SetActorVelocity(0, newVelX, newVelY, newVelZ, false, false);
    }
}

// Al ser algo puramente visual queda del lado del cliente
script "setScale" (int scale) CLIENTSIDE {
    switch(scale) {
        case 1: {
            SetActorProperty(0, APROP_ScaleX, 0.125);
            SetActorProperty(0, APROP_ScaleY, 0.125);
        }; break;
        case 2: {
            SetActorProperty(0, APROP_ScaleX, 0.25);
            SetActorProperty(0, APROP_ScaleY, 0.25);
        }; break;
        case 3: {
            SetActorProperty(0, APROP_ScaleX, 0.375);
            SetActorProperty(0, APROP_ScaleY, 0.375);
        }; break;
        case 4: {
            SetActorProperty(0, APROP_ScaleX, 0.5);
            SetActorProperty(0, APROP_ScaleY, 0.5);
        }; break;
        case 5: {
            SetActorProperty(0, APROP_ScaleX, 0.625);
            SetActorProperty(0, APROP_ScaleY, 0.625);
        }; break;
        case 6: {
            SetActorProperty(0, APROP_ScaleX, 0.75);
            SetActorProperty(0, APROP_ScaleY, 0.75);
        }; break;
        case 7: {
            SetActorProperty(0, APROP_ScaleX, 0.875);
            SetActorProperty(0, APROP_ScaleY, 0.875);
        }; break;
        case 8: {
            SetActorProperty(0, APROP_ScaleX, 1.0);
            SetActorProperty(0, APROP_ScaleY, 1.0);
        }; break;
    }
}

script "getFireRateBoost" (void) {
    SetResultValue(GetUserVariable(0, "user_tear_fire_rate_boost"));
}

script "showPowerups" (int displayFlag) CLIENTSIDE {
    for (int i=1; i<=DISPLAYABLE_POWERUP_MAX; i++) {
        if (displayFlag) {
            SetFont(StrRight(SV_DISPLAYABLE_POWERUPS[i-1], 6));
            if (CheckInventory(StrLeft(SV_DISPLAYABLE_POWERUPS[i-1], StrLen(SV_DISPLAYABLE_POWERUPS[i-1])-6)) == 1) {
                HudMessage(s:"A"; HUDMSG_PLAIN, i, 0, FixedDiv(i << 16, 65.0), 0.05, 0);
            }
            else {
                HudMessage(s:"A"; HUDMSG_PLAIN|HUDMSG_ALPHA, i, 0, FixedDiv(i << 16, 65.0), 0.05, 0, 0.25);
            }
        }
        else {
            HudMessage(s:""; HUDMSG_PLAIN, i, 0, 0, 0, 1);
        }
    }
}

script "checkForNoGiverInInventory" (int option) {
    SetResultValue(CheckInventory(StrLeft(SV_DISPLAYABLE_POWERUPS[option], StrLen(SV_DISPLAYABLE_POWERUPS[option])-6)) == 0);
}

script "checkForNoGiverInTargetInventory" (int option) {
    int ptid = GetActorProperty(0, APROP_TargetTID);
    SetResultValue(CheckActorInventory(ptid, StrLeft(SV_DISPLAYABLE_POWERUPS[option], StrLen(SV_DISPLAYABLE_POWERUPS[option])-6)) == 0);
}

// Por defecto duran 2:30 minutos, se puede agregar un parametro más adelante para duraciones especificas
script "activateTemporalPowerup" (int option) {
    str powerup = StrLeft(SV_DISPLAYABLE_POWERUPS[option], StrLen(SV_DISPLAYABLE_POWERUPS[option])-6);
    GiveInventory(powerup, 1);

    switch(option) {
        case 26: {
            ACS_NamedExecuteAlways("addTearBoost", 0, 2, 1);
            ACS_NamedExecuteAlways("addTearBoost", 0, 6, -2);
            ACS_NamedExecuteAlways("addTearBoost", 0, 4, -75);
            //ACS_NamedExecuteAlways("addTearBoost", 0, 1, 2); //Más height (para cuando zandro lo soporte)
        }
    }

    Delay(5250);

    switch(option) {
        case 26: {
            ACS_NamedExecuteAlways("addTearBoost", 0, 2, -1);
            ACS_NamedExecuteAlways("addTearBoost", 0, 6, 2);
            ACS_NamedExecuteAlways("addTearBoost", 0, 4, 75);
            //ACS_NamedExecuteAlways("addTearBoost", 0, 1, -2); //Más height (para cuando zandro lo soporte)
        }
    }

    TakeInventory(powerup, 1);
}

script "setParasiteChildrenStats" (int ctid) {
    int masterDmg = GetActorProperty(0, APROP_Damage);
    int masterScaleX = GetActorProperty(0, APROP_ScaleX);
    int masterScaleY = GetActorProperty(0, APROP_ScaleY);

    SetActivator(ctid);

    SetActorProperty(0, APROP_Damage, masterDmg / 2);

    //Lo mismo sería para height y radius
    SetActorProperty(0, APROP_ScaleX, masterScaleX / 2);
    SetActorProperty(0, APROP_ScaleY, masterScaleY / 2);

    int range = GetUserVariable(0, "user_deadflag");
    if (range < 5) { range = 5; }
    ACS_NamedExecuteAlways("setRange", 0, range);
    Thing_ChangeTID(ctid, 0);
}

script "isDamageTooLow" (int threshold) {
    SetResultValue(GetActorProperty(0, APROP_Damage) < threshold);
}

script "checkForBackstabDebuff" (void) {
    int projectileAngle = GetActorAngle(0) >> 8;
    int projectileDamage = GetActorProperty(0, APROP_Damage);

    SetActivator(0, AAPTR_TRACER);

    int monsterAngle = GetActorAngle(0) >> 8;
    int minThreshold, maxThreshold;

    if (monsterAngle >= 32 && monsterAngle < 224) {
        minThreshold = monsterAngle - 32;
        maxThreshold = monsterAngle + 32;
        if (projectileAngle >= minThreshold && projectileAngle <= maxThreshold) {
            ACS_NamedExecuteAlways("dealBackstabDamage", 0, projectileDamage);
        }
    }
    else {
        if (monsterAngle < 32) {
            minThreshold = monsterAngle + 224;
            maxThreshold = monsterAngle + 32;
            if (projectileAngle >= minThreshold || projectileAngle <= maxThreshold) {
                ACS_NamedExecuteAlways("dealBackstabDamage", 0, projectileDamage);
            }
        }
        else {
            minThreshold = monsterAngle - 224;
            maxThreshold = monsterAngle - 32;
            if (projectileAngle <= minThreshold || projectileAngle >= maxThreshold) {
                ACS_NamedExecuteAlways("dealBackstabDamage", 0, projectileDamage);
            }
        }
    }
}

script "dealBackstabDamage" (int damage) {
    // Segundo golpe y efecto bleeding
    Thing_Damage2(0, damage, "None");
    ACS_NamedExecuteAlways("applyEffect", 0, 6);
}